cocos2d-x框架流程：		http://m.oschina.net/blog/72202
框架类（AppDelegate（CCApplication）（应用程序主流程）->CCEGLView（创建窗口）->CCDisplayLinkDirector(CCDirector)（主循环）->CCScene（场景）->推动力：事件（时间事件、帧事件、渲染事件）、CCScheduler、CCTimer、CCLayer、CCNode）

1.CCApplication与AppDelegate（单例）
CCApplication是AppDelegate的一个抽象基类。主要初始化OpenGL示例初始化，设置资源路径等。
-virtual bool applicationDidFinishLaunching() = 0;//在AppDelegate中实现，初始化CCDirector 和CCScene
-virtual void applicationDidEnterBackground() = 0;//在AppDelegate中实现，游戏退至后台时调用
-virtual void applicationWillEnterForeground() = 0;//在AppDelegate中实现，游戏恢复前台时调用


1.CCEGLView
窗口类，主要用来创建窗口，接收窗口事件，调节窗口大小等。

1.audio   sound
SimpleAudioEngine in namesapce CocosDenshion.   
Fmod----跨平台音频库

SimpleAudioEngine use FmodAudioPlayer with it's operator（组合）. and they have an
parent pure virtual class AudioPlayer.(作为接口)， FomdAudioPlayer use
Fmod库。

用于控制各种music, 是否循环播放， 已经音效， 音量等。
注意的是在程序退出之前需要调用 static end();函数释放资源
end()释放了由FmodAudioPlayer分配的voice 操作控制对象。


2.file operator
FileUtils ---- > 内部做了一层cache  <file_name, file_content>,
		  如果没找到cache就open     （什么时候clear cache 释放资源）
   fullPathForFilename(std::string filename); ----> get the path

3.CCTextureCache
与FileUtils一样在内部也做了一层cache <full_path, Texture2D *> 
其真正的实例位于游戏的director类中。 每次的static
调用都是获取director实例中的CCTextureCache对象。

CCTexture2D *xxx_Texture =
CCTextureCache::sharedTextureCache()->addImage("xxx.png");

CCSpriteFrame *frame1, frame2, frame3;
frame1 = CCSpriteFrame::frameWithTexture(xxx_Texture,
		cocos2d::CCRectMake());通过帧组合成动画，并在Sprite中应用这个动画就能实现人物的行走特效。
CCSprite *hero = CCSprite::spriteWithSpriteFrame(frame1);
hero->setPosition(ccp(100,100));
addChild(hero);

4.CCTimer:
update定时器 & interval定时器
update定时器每个节点只能注册一个，带优先级
interval定时器每个节点可以注册很多个，根据回调函数不同来执行一个节点的不同函数。


5.CCScheduler :  http://www.cnblogs.com/songcf/p/3162414.html
那么要为一个不加入场景的节点（如：全局网络派发器）添加调度器，就需要自己调用它的以下两个函数：
onEnter();
onEnterTransitionDidFinish();
这样，该节点的调度器就不会被暂停了。


6.CCDirector VS CCDisplayLinkDirector
有四种Director:
    - kCCDirectorTypeNSTimer (default) 
    - kCCDirectorTypeMainLoop 
    - kCCDirectorTypeThreadMainLoop 
    - kCCDirectorTypeDisplayLink			（暂时只有这个director）

前者是抽象类，后者是具体类，在cocos2d-x中用的就是这个具体类（单例）。



7.CCAnimation  &  CCAnimationCache(管理CCAnimation)
	CCAnimate是一个CCActionInterval的子类属于动作，可以通过动画框架初始化
	cocos2d::CCAnimate::actionWithAnimation(anim);

8.菜单的相应类
				CCMenu
				   |
			  CCMenuItem
			       |
	-------------------------------------------------------------
	|					|					|					|
CCMenuItemLabel   CCMenuItemImage   CCMenuItemFont	CCMenuItemToggle
CCMenuItemSprite


9.CCSpriteBatchNode是对sprite_sheet已经plist（资源定位配置文件）的一种操作类。
CCSpriteFrameCache::sharedSpriteFrameCache()->addSpriteFramesWithFile("sprite_sheet.plist");
_gameBatchNode = CCSpriteBatchNode::create("sprite_sheet.png");
this->addChild(_gameBatchNode);
sprite = CCSprite::createWithSpriteFrameName("trees.png"); //	这里的.png都在plist里面定义好了。


======================================
======================================
======================================
======================================
基本类型：
			object ---->用成员函数指针来完成方法传递与调用。
			   |
			  Node  ----->node用vector保存child并有一个parent指针。

CCSet/CCSetIterator:		是对std::set的封装，底层容器std::set<object *>


<CCObject的内存管理>，其中有一个m_uAutoReleaseCount,是用于对象在多个autoreleasePool中被持有而用的。
之所以需要经常的retain()一个对象，是因为一个对象在被创建的时候是在这一帧的autoReleasePool中被管理，但是当到下一帧的时候这个pool就会release其管理的所有对象，所以如果我们需要一个对象一直有用最好retain()它不然它就在下一帧被free。(但这时候我们就需要手动的来release()这个对象了再需要释放的时候)。
其中layer、scene都是天生的autorelease object.
注意：渲染树结构与链式反应(两个其实是一个原理不同的说发而已)!!!!!!   一般而言，内部组成树形结构的链式反应，如 CCNode）。链式反应，也就是，如果释放一个对象，也会释放它所引用的对象。
一个scene携带其下的所有层以及精灵构成的一个庞大的渲染树再析构树的root的时候会析构其下的所有元素。
而所谓的链式反应则是经一个对象放入另一个对象的内部（作为一个内部引用），而不在别的地方进行retain(),当这个对象被free的时候其内部引用的对象也会被free.
而我们自己临时new的一个对象如果我们以autoreleasePool来管理它（通常用create静态方法创建对象的时候），如果我们想在其他地方用到该对象我们就需要对他retain。否则他只能在当前作用域有效，因为在下一帧它就会被free,而产生野指针crash.






======================================
======================================
======================================
======================================
项目文件划分：
------- util
------- scene(是图层控制的基础，直接由director调用，负责场景切换。)
------- layer	(精灵层<所有可动物体的基类> 、 控制层、
		特效层<咱都特效，扣血弹tip等>、 )
------- model
------- map(地图往往是读取tmx文件获得的， 像ARPG游戏可能有多种类型的地图)
	每一个map最后都被layer这个容器所容纳。 
------- AI
------- Sprite(精灵) 












======================================
======================================
======================================
======================================
代码片段：
*给map中的各个图层添加抗锯齿效果
void GameMap::enableAnitiAliasForEachLayer()
{
	CCArray * pChildrenArray = this->getChildren();
	CCSpriteBatchNode* child = NULL;
	CCObject* pObject = NULL;
	//遍历Tilemap的所有图层
	CCARRAY_FOREACH(pChildrenArray, pObject)
	{
		child = (CCSpriteBatchNode*)pObject;
		if(!child)
			break;
		//给图层的纹理开启抗锯齿
		child->getTexture()->setAntiAliasTexParameters();
	}
}


*图层中的元素属性获取
//遍历所有对象
for( it = objects->begin(); it != objects->end(); it++) 
{
	dict = (*it);
	if(!dict)
		break;
	std::string key = "x";
	//获取x坐标
	int x = dict->objectForKey(key)->toInt();
	key = "y";
	//获取y坐标
	int y = dict->objectForKey(key)->toInt();
	CCPoint tileCoord = tileCoordForPosition(ccp(x, y));
	//计算唯一ID
	int index = tileCoord.x + tileCoord.y * this->getMapSize().width;
	key = "type";
	//获取对象类别
	CCString *type = dict->objectForKey(key);
	//如果类型是传送门
	if (type->m_sString == "teleport"){
		Teleport *teleport = new Teleport(dict, x, y);
		teleportDict->setObject(teleport, index);
	}
	//如果类型是NPC对象
	else if (type->m_sString == "npc"){
		NPC *npc = new NPC(dict, x, y);
		npcDict->setObject(npc, index);
	}
}




